% TOMLAB OQNLP MINLP Solver
%
% function Result = tomRun('oqnlp',Prob);
%
% OQNLP solves constrained nonlinear mixed-integer problems of
% the type:
%
%    min f(x)
%
%    subject to
%
%    x_L <=  x   <= x_U, variable bounds
%    b_L <= A*x  <= b_U, linear constraints
%    c_L <= c(x) <= c_L, nonlinear constraints
%
%  where x_L, x_U, x are n*1-vectors, b_L,b_U are m1*1-vectors, A is a dense
%  or sparse m1*n matrix, and c_L, c_U, c(x) are m2*1-vectors.
%
%  Furthermore, x_i are restricted to integer values for i in I, 
%  where I is a subset of {1,2,...,n}, x in R^n
%
% ------------------------------------------------------------------
%
% INPUT:  
%
% Prob          Problem structure in TOMLAB format. Fields used are:
%
%    A          Linear constraints coefficient matrix.
%    x_L, x_U   Bounds on variables. 
%    b_L, b_U   Bounds on linear constraints. 
%    c_L, c_U   Bounds on nonlinear constraints.
%               For equality constraints (or fixed variables), set
%               e.g. b_L(k) == b_U(k).
%    
%    PriLevOpt  Print level in MEX interface.
%
%    LargeScale Flag telling whether to treat the problem as sparse (1) or
%               dense. If set to 1, the user should also provide a sparse
%               0-1 matrix in Prob.ConsPattern giving the nonzero pattern.
%     
%    MaxCPU     Maximum allowed time in seconds for the OQNLP run. 
%               It is also possible to set this through the Prob.OQNLP.options.MAXTIME
%               parameter, in which case Prob.MaxCPU is ignored. OQNLP's
%               default value for MAXTIME is 1000 seconds. 
%
%               Note that you may not necessarily get the "Time limit
%               exceeded" message from the solver although it stops because
%               of this. 
%
% Prob.optParam Structure with optimization parameters. The following fields are used:
%
%    MaxIter    Maximum number of trial points to be generated by the OptQuest 
%               component embedded in OQNLP. Default: 1000
%
%               Increasing this limit can allow OQNLP to find a better solution.
%               The default is 1000 iterations. Try to raise it if your run using 1000 
%               iterations doesn’t take too long. Surprisingly, the best solution
%               using, say 2000 iterations, may be found in the first 1000 iterations, 
%               and that solution may be better than the one found with an iteration
%               limit of 1000. This is because OptQuest changes its search strategy 
%               depending on the iteration limit. Because of this, it is also possible 
%               that increasing the iteration limit will yield a worse solution, but this 
%               is rare. Decreasing this iteration limit usually leads to a worse solution, 
%               but also reduces run time.
%
% Prob.MIP      Structure with fields defining the integer properties of
%               the problem. The following fields are used:
%
%    IntVars    Vector designating which variables are restricted
%               to integer values. This field is interpreted
%               differently depending on the length. 
%
%               If length(IntVars) = length(x), it is interpreted as a
%               zero-one vector where all non-zero elements
%               indicate integer values only for the corresponding variable.
%
%               A length less than the problem dimension indicates
%               that IntVars is a vector of indices for the integer
%               variables, for example [1 2 3 6 7 12].
%
%               A scalar value K restricts variables x(1) through
%               x(K) to take integer value only.
%
%
% Prob.OQNLP    Structure with special fields for the OQNLP solver:
%
%    options    Structure array with options. 
%               See the Tomlab /OQNLP User's Guide for instructions and examples.
%
%    PrintFile  Name of file to receive the OQNLP iteration and results
%               log. Independent of PriLevOpt.
%
% OUTPUT: 
% Result   Structure with optimization results 
%
%   f_k      Function value at optimum.
%   g_k      Gradient of the function.
%
%   x_k      Solution vector.
%   x_0      Initial solution vector.
%
%   c_k      Nonlinear constraint residuals.
%   cJac     Nonlinear constraint gradients.
%
%
%   xState   State of variables. Free == 0; On lower == 1; On upper == 2; 
%            Fixed == 3;
%   bState   State of linear constraints. Free == 0; Lower == 1; Upper == 2; 
%            Equality == 3;
%   cState   State of nonlinear constraints. Free == 0; Lower == 1; Upper == 2; 
%            Equality == 3;
%
%   v_k        Lagrangian multipliers (for bounds + dual solution vector).
%
%   ExitFlag   Exit status.
%
%   Inform     OQNLP information parameter.
%
%   rc               Reduced costs. If ninf=0, last m == -v_k.
%   Iter             Number of iterations.
%   FuncEv           Number of function evaluations.
%   GradEv           Number of gradient evaluations.
%   ConstrEv         Number of constraint evaluations.
%   QP.B             Basis vector in TOMLAB QP standard.
%   Solver           Name of the solver ('oqnlp').
%   SolverAlgorithm  Description of the solver.
%
%
% -------------------------------------------------------------------------
%
% Anders Goran, Tomlab Optimization Inc, E-mail: tomlab@tomlab.biz
% Copyright (c) 2003-2005 by Tomlab Optimization Inc., $Release: 4.7.0 $
% Written Apr 8, 2003.   Last modified Jan 22, 2005.
%

function Result = oqnlpTL(Prob)

if nargin < 1, error('oqnlpTL needs the Prob structure as input');return;end

Prob.solvType = 12; % MINLP solver

Prob = iniSolve(Prob,12,1,1);

Result=ResultDef(Prob);
Result.Solver = 'OQNLP';

LargeScale = DefPar(Prob,'LargeScale',0);

switch(LargeScale)
    case 0,
        Result.SolverAlgorithm = 'Dense Multistart GRG OQNLP 2.0';
    otherwise,
        Result.SolverAlgorithm = 'Sparse Multistart GRG OQNLP 2.0';
end

PriLev = DefPar(Prob,'PriLevOpt',0);

% OQNLP cannot have large BIG  
BIG=1E4;
[bl,bu,n,m1,m2] = defblbu(Prob,BIG,1);

% OQNLP might have a problem with "reversed" bounds 
idx = find(bl>bu);
if ~isempty(idx)
   % Any bounds where bl>bu are adjusted to equalities
   bl(idx)=bu(idx);
   if Prob.Warning > 0
      fprintf( ['\nWarning: Adjusting reversed bounds.\nTo disable this message, set Prob.Warning=0\n\n'] );
   end
end     
   
m = m1+m2;

% Safe guarded starting point x_0:
x_0 = DefPar(Prob,'x_0',zeros(n,1));
x_0 = max(bl(1:n),min(bu(1:n),x_0));

% Function value at x_0
Result.f_0 = nlp_f(x_0,Prob);
Result.x_0 = x_0;

% Integer properties
IV  = DefPar(Prob.MIP,'IntVars',[]);

if isempty(IV)
   IntVars=[];
elseif length(IV)==1
   IntVars=[1:min(n,max(0,floor(IV)))];
elseif length(IV) < n
   IntVars=IV;
else
   IntVars=find(IV > 0);
end

% oqnlp needs 0-1 n-vector, not vector of indices like we have now.
IV = zeros(n,1);
IV(IntVars) = 1;

% OQNLP substructure with solver-specific fields
OQNLP = DefPar(Prob,'OQNLP',[]);

% iprint, not used anymore
%iprint    = DefPar(OQNLP,'iprint',[]);
%if isempty(iprint)
%    iprint = PriLev;
%end
iprint = [];

PrintFile = DefPar(OQNLP,'PrintFile','');

% StdFile, not used anymore. Should be removed from mex input argument list.
%StdFile   = DefPar(OQNLP,'StdFile','oqnlpstd.txt');
StdFile = '';

options = DefPar(OQNLP,'options',[]);
if ~isfield(options,'ITERATION_LIMIT')
   options.ITERATION_LIMIT = DefPar(Prob.optParam,'MaxIter',[]);
end

MaxCPU = DefPar(Prob,'MaxCPU',inf);
if ~isfield(options,'MAXTIME') & isfinite(MaxCPU)
   options.MAXTIME = MaxCPU;
end

Prob.OQNLP.options = options;

if LargeScale
   if issparse(Prob.A)
      A = Prob.A;
   else
      A = sparse(Prob.A);
   end

   if isempty(Prob.ConsPattern)
      ConsPattern = sparse( ones(m2,n) );
   else
      ConsPattern = sparse( Prob.ConsPattern );
   end
   
   nz = nnz(A)+nnz(ConsPattern)+n;
else
   A = full(Prob.A);
   ConsPattern = [];
   nz = (m+1)*n;
end

if ~isempty(IntVars)
    if Prob.simType > 0
        if isempty(Prob.USER.gdc) | (Prob.ConsDiff > 0 ) | (Prob.NumDiff > 0)
            Prob.USER.gdc = 'oqnlp_gdc';  % Special interface routine
            Prob.MIP.IntVars = IntVars;   % To avoid doing tests on IntVars
            Prob.CheckNaN = 1;
            Prob.ConsDiff = 0;
            Prob.NumDiff = 0;
            global NARG
            NARG(11) = 2;
            if isempty(ConsPattern)
                Prob.ConsPattern = ones(m2,n);
                Prob.ConsPattern(:,IntVars) = 0;
            else
                Prob.ConsPattern(:,IntVars) = 0;
            end
        end
    else
        if isempty(Prob.USER.g) | (Prob.NumDiff > 0)
            Prob.USER.g = 'oqnlp_g';      % Interface routine for gradient
            Prob.MIP.IntVars = IntVars;   % To avoid doing tests on IntVars
            Prob.CheckNaN = 1;
            global NARG
            NARG(2) = 2;
        end
        if isempty(Prob.USER.dc) | (Prob.ConsDiff > 0 )
            Prob.USER.gdc = 'oqnlp_dc';   % Interface routine for Jacobian
            Prob.MIP.IntVars = IntVars;   % To avoid doing tests on IntVars
            Prob.CheckNaN = 1;
            global NARG
            NARG(5) = 2;
            if isempty(ConsPattern)
                Prob.ConsPattern = ones(m2,n);
                Prob.ConsPattern(:,IntVars) = 0;
            else
                Prob.ConsPattern(:,IntVars) = 0;
            end
        end
    end
end

if m2 > 0
   % Determine the sparse problem structure
   if ~isempty(ConsPattern)
      [ix,iy]=find(ConsPattern);
      
      % Send linear index from multiple subscripts for nonzero pattern
      Prob.ConsIdx = sub2ind(size(ConsPattern),ix,iy);
   end
end

% The call
[rc, x_k, f_k, c_k, v_k,inbind,redgr] = ...
   oqnlp(n,m1,m2,...
   nz,ConsPattern,A,bl,bu,...
   x_0,IV, PriLev,PrintFile,StdFile,iprint,Prob);

% New type of return code, needs some bitwise arithmetics
if rc >= 2^16
   rc_loc = bitand(rc,2^16-1); % Filter out the low bits, which is the local solution status
   rc_alg = bitshift(rc-rc_loc,-16);
elseif rc < 0
   rc_loc = -bitand(-rc,2^16-1);
   rc_alg = bitshift(-rc-rc_loc,-16);
else
   % Don't think this will happen.
   rc_loc = 0;
   rc_alg = rc;
end

%       i = oqnlpLocalSolStatus;
%       if(i < 0) {
%          i = -i;
%          info = (oqnlpAlgTermination << 16) + i;
%          info = -info;
%       }
%       else info = (oqnlpAlgTermination << 16) + i;

Inform   = rc_loc;
% "Raw" outputs from oqnlp:
Result.OQNLP.ifail    = rc;
Result.OQNLP.rc_loc   = rc_loc;
Result.OQNLP.rc_alg   = rc_alg;
Result.OQNLP.rmults   = v_k;
Result.OQNLP.inbind   = inbind;
Result.OQNLP.redgr    = redgr;

% Recalculate final values - if not successful, some outputs from
% oqnlp may be wrong
Result.x_k = x_k;

Result.f_k = nlp_f(x_k,Prob);

if ~isempty(Prob.USER.g), Result.g_k = nlp_g(x_k,Prob); else Result.g_k =[]; end
if ~isempty(Prob.USER.H), Result.H_k = nlp_H(x_k,Prob); else Result.H_k =[]; end

if m2 > 0
  Result.c_k = nlp_c(x_k,Prob);
  if ~isempty(Prob.USER.dc)
    Result.cJac = nlp_dc(x_k,Prob);
  end
end

if m1 > 0
  Result.Ax = Prob.A*x_k;
else
  Result.Ax = [];
end

% Crude set of exit texts

%
% Two status codes: Algorithm status and local solution status. The
% algorithm status tells us why the multi start algorithm stopped
% searching. The local solution status gives us information on the
% status of the best local solution. These two are combined into
% one big exit text.
%

ExitFlag = [];
AlgExitText = [];
AlgShortexitText = [];
LocExitText = [];

switch(rc_alg)
 case 1,
  AlgExitText = 'Iteration limit exceeded.';
 case 2,
  AlgExitText = 'Time limit exceeded.';
 case 3,
  AlgExitText = 'Locals limit exceeded.';
 case 4,
  AlgExitText = 'Solver call exceeded.';
 case 5,
  AlgExitText = 'Local solution improvement criterion met.';
 case 6,
  AlgExitText = 'User termination.';
end

switch(rc_loc)
   case {-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1}
      switch(Inform)
         case -17,   LocShortExitText='PROBLEM_STRUCTURE';  
         case -16,   LocShortExitText='ANAJAC_BAD_COL';
         case -15,   LocShortExitText='BAD_USER_NNZ';
         case -14,   LocShortExitText='ALLOCTBL_OVERFLOW';
         case -13,   LocShortExitText='MISSING_GCOMPX';
         case -12,   LocShortExitText='MISSING_PARSH';
         case -11,   LocShortExitText='MISSING_GCOMP';
         case -10,   LocShortExitText='BAD_OPTION_VALUE';
         case -9,    LocShortExitText='BOUNDS_ERROR';
         case -8,    LocShortExitText='LINEAR_VARS_ERROR';
         case -7,    LocShortExitText='BAD_NOBJ';
         case -6,    LocShortExitText='DIMENSION_ERROR';
         case -5,    LocShortExitText='BAD_COMMAND';
         case -4,    LocShortExitText='INTERNAL_ERROR';
         case -3,    LocShortExitText='INVERT_FAILURE';
         case -2,    LocShortExitText='INSFMEMORY';
         case -1,    LocShortExitText='BADINPUT';
      end
      
    LocExitText='Setup error.';
    ExitFlag=10;
    
 case  0,    LocShortExitText='STATUS_NOT_SET';
    LocExitText='Status not set.';
    ExitFlag=11;
    
 case  1,
    LocShortExitText='KTC';
    LocExitText='Kuhn-Tucker conditions satisfied.';
    ExitFlag = 0;
    
 case  2,    LocShortExitText='FRACTCHG';
  LocExitText='Fractional change in objective too small.';
  ExitFlag = 0;
  
 case  3,    LocShortExitText='ALLREMEDIES';
  LocExitText='All remedies failed.';
  ExitFlag=0; % ??
  
 case  4,
  LocShortExitText='ITERATIONS';
  LocExitText='Too many iterations.';
  ExitFlag=1;
  
 case  5,
  LocShortExitText='UNBOUNDED';
  LocExitText = 'Problem is unbounded.';
  ExitFlag = 2;
  
    
 case {6,7,8,9,10}
    switch(Inform)
       case  6,    LocShortExitText='INFEASIBLE_KTC';
       case  7,    LocShortExitText='INFEASIBLE_FRACTCHG';
       case  8,    LocShortExitText='INFEASIBLE_ALLREMEDIES';
       case  9,    LocShortExitText='INFEASIBLE_ITERATIONS';
       case 10,    LocShortExitText='INFEASIBLE';
    end
    LocExitText = 'Problem infeasible.';
    ExitFlag = 4;
    
 case 11,    LocShortExitText='SETUP_SUCCESS';
 case 12,    LocShortExitText='SHUTDOWN_SUCCESS';
 case 13,    LocShortExitText='REDOBJ_CONSTVIOL'; 
 case 14,    LocShortExitText='REDGRA_NB_LE_0'; 
 case 15,    LocShortExitText='XDOT_COLLEN'; 
 case 16,    LocShortExitText='XSAXPY_COLLEN'; 
 case 17,    LocShortExitText='GETBAS_INSFMEM'; 
 case 18,    LocShortExitText='XPIVOT_COLLEN'; 
 case 19,    LocShortExitText='CHUZQ_BADPIVOT'; 
 case 20,    LocShortExitText='XPIVOT_BASIS_ILLCOND'; 
 case 21,    LocShortExitText='XPIVOT_BASIS_SING'; 
 case 22,    LocShortExitText='XPIVOT_INSFMEM'; 
 case 23,    LocShortExitText='XPIVOT_OTHER_ERR'; 
 case 24,    LocShortExitText='CONSBS_REINVERT_BC'; 
 case 25,    LocShortExitText='CONSBS_BASIS_STRUCTURE'; 
 case 26,    LocShortExitText='CONSBS_NOINVERT_SEARCH'; 
 case 27,    LocShortExitText='CONSBS_BASIC_SLACK'; 
 case 28,    LocShortExitText='CONSBS_JPIV_0'; 
 case 29,    LocShortExitText='CONSBS_NB_TOOBIG'; 
 case 30,    LocShortExitText='CONDNM_BAD_NBLOCKS'; 
 case 31,    LocShortExitText='CONDNM_BAD_COLLEN'; 
 case 32,    LocShortExitText='DIREC_UPDATE_ERR'; 
 case 33,    LocShortExitText='PH0FAC_INVERT_FAILURE '; 
 case 34,    LocShortExitText='PH0PIV_BAD_INDEX'; 
 case 35,    LocShortExitText='PH0PIV_XPIVOT_FAILURE'; 
 case 36,    LocShortExitText='PH0PIV_BAD_ICOLS1'; 
 case 37,    LocShortExitText='PH0PIV_BAD_ICOLS2'; 
 case 38,    LocShortExitText='OTHER_RUNTIME'; 
 
 case 39,
  LocShortExitText='USER_TERMINATION'; 
  LocExitText = 'Terminated by user function.';
  ExitFlag = 12;
 
 case 40,    LocShortExitText='JAC_OVERFLOW'; 
 
 case 41,
  LocShortExitText='OPTQUEST_ERROR'; 
  LocExitText = 'OPTQUEST Error.';
  ExitFlag = 13;
  
 case 42,
  LocShortExitText='TIME_LIMIT_EXCEEDED';
  LocExitText = 'Time limit exceeded.';
  ExitFlag = 1;

 case 43,
  LocShortExitText = 'NO_LOCALS_FOUND_INFEASIBLE';
  LocExitText = 'No locals found. Infeasible.';
  ExitFlag = 4;
  
 case 44,
  LocShortExitText = 'NO_LOCALS_FOUND_FEASIBLE';
  LocExitText = 'No locals found. Feasible.';
  ExitFlag = 4;
  
otherwise,
  LocShortExitText='';
  LocExitText=['Unknown return code ' num2str(Inform) ' (' num2str(rc) ').' ];
  ExitFlag = -1;
end

if isempty(LocExitText)
  LocExitText = deblank(LocShortExitText);
else
  LocExitText = deblank(LocExitText);
end

if isempty(AlgExitText)
  AlgExitText = 'Unknown.';
end

Result.OQNLP.AlgExitText = AlgExitText;
Result.OQNLP.LocExitText = LocExitText;

Result.ExitText = sprintf('%s %s\n%s %s', ...
                          'Sol. status:', ...
                          LocExitText, ...
                          'Alg. status:', ...
                          AlgExitText);

Result.ExitFlag = ExitFlag;
Result.Inform   = rc_loc;

% Constraint values
% if m1>0, Result.Ax  = c_k(1:m1); else Result.Ax=[]; end
% Result.c_k = c_k(m1+1:m);
% 
% Result.cJac = nlp_dc(x_k,Prob);

% Multipliers
Result.v_k = v_k;

% Variable/constraint states
optParam = Prob.optParam;

Result = StateDef(Result, x_k, Result.Ax, Result.c_k, optParam.xTol, ...
                  optParam.bTol, optParam.cTol, bl, bu, 1);

Result=endSolve(Prob,Result);

% MODIFICATION LOG
% 
% 030414 ango Wrote file
% 030904 ango x/b/cStates now correctly returned
% 031118 ango LargeScale handling slightly changed
% 031210 ango Change comment on calling syntax
% 040102 hkh  Revision for v4.2, call iniSolve and endSolve
% 040128 hkh  Safeguard for patological equalities in A, rhs > abs(BIG)
% 040507 ango Fixed for bit-combined return codes from OQNLP solver
% 040526 hkh  Wrong call to iniSolve, only 1st order information needed
% 040602 ango Added Prob.MaxCPU handling. 
% 040928 ango Safeguard for reversed bounds.
% 041112 hkh  Use oqnlp_gdc for automatic avoidance of IntVars for num.diff
% 041112 frhe Added help text about PrintFile.
% 041202 hkh  Revise calls to defblbu and StateDef, avoid vector reshuffling
% 041202 hkh  Unnecessary tests removed
% 050112 frhe Status codes handled totally different now.
% 050122 hkh  Inform used, but not set as rc_loc
