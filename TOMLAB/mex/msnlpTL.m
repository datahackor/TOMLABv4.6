% TOMLAB MSNLP GLC Solver
%
% function Result = tomRun('msnlp',Prob);
%
% MSNLP solves constrained nonlinear mixed-integer problems of
% the type:
%
%    min f(x)
%
%    subject to
%
%    x_L <=  x   <= x_U, variable bounds
%    b_L <= A*x  <= b_U, linear constraints
%    c_L <= c(x) <= c_L, nonlinear constraints
%
%  where x_L, x_U, x are n*1-vectors, b_L,b_U are m1*1-vectors, A is a dense
%  or sparse m1*n matrix, and c_L, c_U, c(x) are m2*1-vectors.
%
% ------------------------------------------------------------------
%
% INPUT:  
%
% Prob          Problem structure in TOMLAB format. Fields used are:
%
%    A          Linear constraints coefficient matrix.
%    x_L, x_U   Bounds on variables. 
%    b_L, b_U   Bounds on linear constraints. 
%    c_L, c_U   Bounds on nonlinear constraints.
%               For equality constraints (or fixed variables), set
%               e.g. b_L(k) == b_U(k).
%    
%    PriLevOpt  Print level in MEX interface.
%
%    LargeScale Flag telling whether to treat the problem as sparse (1) or
%               dense. If set to 1, the user should also provide a sparse
%               0-1 matrix in Prob.ConsPattern giving the nonzero pattern.
%     
%    MaxCPU     Maximum allowed time in seconds for the MSNLP run. 
%               It is also possible to set this through the Prob.OQNLP.options.MAXTIME
%               parameter, in which case Prob.MaxCPU is ignored. MSNLP's
%               default value for MAXTIME is 1000 seconds.
%
%               Note that you may not necessarily get the "Time limit
%               exceeded" message from the solver although it stops because
%               of this.
%
% Prob.optParam Structure with optimization parameters. The following fields are used:
%
%    MaxIter    Maximum number of trial points to be generated by the MSNLP 
%               multistart algorithm. Default: 1000
%
%               Increasing this limit can allow MSNLP to find a better solution.
%               The default is 1000 iterations. Try to raise it if your run using 1000 
%               iterations doesn’t take too long.
%
% Prob.OQNLP    Structure with special fields for the MSNLP solver:
%
%    options    Structure array with options.
%               See the TOMLAB /MSNLP User's Guide for instructions and examples.
%
%    PrintFile  Name of file to receive the MSNLP iteration and results
%               log. Independent of PriLevOpt.
%
% OUTPUT: 
% Result   Structure with optimization results 
%
%   f_k      Function value at optimum.
%   g_k      Gradient of the function.
%
%   x_k      Solution vector.
%   x_0      Initial solution vector.
%
%   c_k      Nonlinear constraint residuals.
%   cJac     Nonlinear constraint gradients.
%
%
%   xState   State of variables. Free == 0; On lower == 1; On upper == 2; 
%            Fixed == 3;
%   bState   State of linear constraints. Free == 0; Lower == 1; Upper == 2; 
%            Equality == 3;
%   cState   State of nonlinear constraints. Free == 0; Lower == 1; Upper == 2; 
%            Equality == 3;
%
%   v_k        Lagrangian multipliers (for bounds + dual solution vector).
%
%   ExitFlag   Exit status.
%
%   Inform     MSNLP information parameter.
%
%   rc               Reduced costs. If ninf=0, last m == -v_k.
%   Iter             Number of iterations.
%   FuncEv           Number of function evaluations.
%   GradEv           Number of gradient evaluations.
%   ConstrEv         Number of constraint evaluations.
%   QP.B             Basis vector in TOMLAB QP standard.
%   Solver           Name of the solver ('msnlp').
%   SolverAlgorithm  Description of the solver.
%
%
% -------------------------------------------------------------------------
%
% Anders Goran, Tomlab Optimization Inc, E-mail: tomlab@tomlab.biz
% Copyright (c) 2003-2004 by Tomlab Optimization Inc., $Release: 4.6.0 $
% Written Apr 8, 2003.   Last modified Dec 16, 2004.
%

function Result = msnlpTL(Prob)

if nargin < 1, error('msnlpTL needs the Prob structure as input');return;end

Prob.solvType = 10; % GLC solver

Prob = iniSolve(Prob,10,1,1);

Result=ResultDef(Prob);
Result.Solver = 'MSNLP';

LargeScale = DefPar(Prob,'LargeScale',0);

switch(LargeScale)
    case 0,
        Result.SolverAlgorithm = 'Dense Multistart GRG MSNLP 2.0';
    otherwise,
        Result.SolverAlgorithm = 'Sparse Multistart GRG MSNLP 2.0';
end

PriLev = DefPar(Prob,'PriLevOpt',0);

% MSNLP cannot have large BIG  
BIG=1E4;
[bl,bu,n,m1,m2] = defblbu(Prob,BIG,1);

% MSNLP might have a problem with "reversed" bounds 
idx = find(bl>bu);
if ~isempty(idx)
   % Any bounds where bl>bu are adjusted to equalities
   bl(idx)=bu(idx);
   if Prob.Warning > 0
      fprintf( ['\nWarning: Adjusting reversed bounds.\nTo disable this message, set Prob.Warning=0\n\n'] );
   end
end     
   
m = m1+m2;

% Safe guarded starting point x_0:
x_0 = DefPar(Prob,'x_0',zeros(n,1));
x_0 = max(bl(1:n),min(bu(1:n),x_0)); 

% Function value at x_0
Result.f_0 = nlp_f(x_0,Prob);
Result.x_0 = x_0;

% MSNLP substructure with solver-specific fields
OQNLP = DefPar(Prob,'OQNLP',[]);

iprint = [];

PrintFile = DefPar(OQNLP,'PrintFile','');

StdFile = '';

options = DefPar(OQNLP,'options',[]);
if ~isfield(options,'ITERATION_LIMIT')
   options.ITERATION_LIMIT = DefPar(Prob.optParam,'MaxIter',[]);
end

MaxCPU = DefPar(Prob,'MaxCPU',inf);
if ~isfield(options,'MAXTIME') & isfinite(MaxCPU)
   options.MAXTIME = MaxCPU;
end

Prob.OQNLP.options = options;

if LargeScale
   if issparse(Prob.A)
      A = Prob.A;
   else
      A = sparse(Prob.A);
   end

   if isempty(Prob.ConsPattern)
      ConsPattern = sparse( ones(m2,n) );
   else
      ConsPattern = sparse( Prob.ConsPattern );
   end
   
   nz = nnz(A)+nnz(ConsPattern)+n;
else
   A = full(Prob.A);
   ConsPattern = [];
   nz = (m+1)*n;
end

if m2 > 0
   % Determine the sparse problem structure
   if ~isempty(ConsPattern)
      [ix,iy]=find(ConsPattern);
      
      % Send linear index from multiple subscripts for nonzero pattern
      Prob.ConsIdx = sub2ind(size(ConsPattern),ix,iy);
   end
end

% The call
[rc, x_k, f_k, c_k, v_k,inbind,redgr] = ...
   msnlp(n,m1,m2,...
   nz,ConsPattern,A,bl,bu,...
   x_0,[], PriLev,PrintFile,StdFile,iprint,Prob);

% New type of return code, needs some bitwise arithmetics
if rc >= 2^16
   rc_loc = bitand(rc,2^16-1); % Filter out the low bits, which is the local solution status
   rc_alg = bitshift(rc-rc_loc,-16);
elseif rc < 0
   rc_loc = -bitand(-rc,2^16-1);
   rc_alg = bitshift(-rc-rc_loc,-16);
else
   % Don't think this will happen.
   rc_loc = 0;
   rc_alg = rc;
end

Result.OQNLP.ifail    = rc;
Result.OQNLP.rc_loc   = rc_loc;
Result.OQNLP.rc_alg   = rc_alg;
Result.OQNLP.rmults   = v_k;
Result.OQNLP.inbind   = inbind;
Result.OQNLP.redgr    = redgr;

% Recalculate final values - if not successful, some outputs from
% msnlp may be wrong
Result.x_k = x_k;

Result.f_k = nlp_f(x_k,Prob);

if ~isempty(Prob.USER.g), Result.g_k = nlp_g(x_k,Prob); else Result.g_k =[]; end
if ~isempty(Prob.USER.H), Result.H_k = nlp_H(x_k,Prob); else Result.H_k =[]; end

if m2 > 0
  Result.c_k = nlp_c(x_k,Prob);
  if ~isempty(Prob.USER.dc)
    Result.cJac = nlp_dc(x_k,Prob);
  end
end

if m1 > 0
  Result.Ax = Prob.A*x_k;
else
  Result.Ax = [];
end

% Crude set of exit texts

%
% Two status codes: Algorithm status and local solution status. The
% algorithm status tells us why the multi start algorithm stopped
% searching. The local solution status gives us information on the
% status of the best local solution. These two are combined into
% one big exit text.
%

ExitFlag = [];
AlgExitText = [];
AlgShortexitText = [];
LocExitText = [];

switch(rc_alg)
 case 1,
  AlgExitText = 'Iteration limit exceeded.';
 case 2,
  AlgExitText = 'Time limit exceeded.';
 case 3,
  AlgExitText = 'Locals limit exceeded.';
 case 4,
  AlgExitText = 'Solver call exceeded.';
 case 5,
  AlgExitText = 'Local solution improvement criterion met.';
 case 6,
  AlgExitText = 'User termination.';
end

switch(rc_loc)
   case {-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1}
      switch(Inform)
         case -17,   LocShortExitText='PROBLEM_STRUCTURE';  
         case -16,   LocShortExitText='ANAJAC_BAD_COL';
         case -15,   LocShortExitText='BAD_USER_NNZ';
         case -14,   LocShortExitText='ALLOCTBL_OVERFLOW';
         case -13,   LocShortExitText='MISSING_GCOMPX';
         case -12,   LocShortExitText='MISSING_PARSH';
         case -11,   LocShortExitText='MISSING_GCOMP';
         case -10,   LocShortExitText='BAD_OPTION_VALUE';
         case -9,    LocShortExitText='BOUNDS_ERROR';
         case -8,    LocShortExitText='LINEAR_VARS_ERROR';
         case -7,    LocShortExitText='BAD_NOBJ';
         case -6,    LocShortExitText='DIMENSION_ERROR';
         case -5,    LocShortExitText='BAD_COMMAND';
         case -4,    LocShortExitText='INTERNAL_ERROR';
         case -3,    LocShortExitText='INVERT_FAILURE';
         case -2,    LocShortExitText='INSFMEMORY';
         case -1,    LocShortExitText='BADINPUT';
      end
      
    LocExitText='Setup error.';
    ExitFlag=10;
    
 case  0,    LocShortExitText='STATUS_NOT_SET';
    LocExitText='Status not set.';
    ExitFlag=11;
    
 case  1,
    LocShortExitText='KTC';
    LocExitText='Kuhn-Tucker conditions satisfied.';
    ExitFlag = 0;
    
 case  2,    LocShortExitText='FRACTCHG';
  LocExitText='Fractional change in objective too small.';
  ExitFlag = 0;
  
 case  3,    LocShortExitText='ALLREMEDIES';
  LocExitText='All remedies failed.';
  ExitFlag=0; % ??
  
 case  4,
  LocShortExitText='ITERATIONS';
  LocExitText='Too many iterations.';
  ExitFlag=1;
  
 case  5,
  LocShortExitText='UNBOUNDED';
  LocExitText = 'Problem is unbounded.';
  ExitFlag = 2;
  
    
 case {6,7,8,9,10}
    switch(Inform)
       case  6,    LocShortExitText='INFEASIBLE_KTC';
       case  7,    LocShortExitText='INFEASIBLE_FRACTCHG';
       case  8,    LocShortExitText='INFEASIBLE_ALLREMEDIES';
       case  9,    LocShortExitText='INFEASIBLE_ITERATIONS';
       case 10,    LocShortExitText='INFEASIBLE';
    end
    LocExitText = 'Problem infeasible.';
    ExitFlag = 4;
    
 case 11,    LocShortExitText='SETUP_SUCCESS';
 case 12,    LocShortExitText='SHUTDOWN_SUCCESS';
 case 13,    LocShortExitText='REDOBJ_CONSTVIOL'; 
 case 14,    LocShortExitText='REDGRA_NB_LE_0'; 
 case 15,    LocShortExitText='XDOT_COLLEN'; 
 case 16,    LocShortExitText='XSAXPY_COLLEN'; 
 case 17,    LocShortExitText='GETBAS_INSFMEM'; 
 case 18,    LocShortExitText='XPIVOT_COLLEN'; 
 case 19,    LocShortExitText='CHUZQ_BADPIVOT'; 
 case 20,    LocShortExitText='XPIVOT_BASIS_ILLCOND'; 
 case 21,    LocShortExitText='XPIVOT_BASIS_SING'; 
 case 22,    LocShortExitText='XPIVOT_INSFMEM'; 
 case 23,    LocShortExitText='XPIVOT_OTHER_ERR'; 
 case 24,    LocShortExitText='CONSBS_REINVERT_BC'; 
 case 25,    LocShortExitText='CONSBS_BASIS_STRUCTURE'; 
 case 26,    LocShortExitText='CONSBS_NOINVERT_SEARCH'; 
 case 27,    LocShortExitText='CONSBS_BASIC_SLACK'; 
 case 28,    LocShortExitText='CONSBS_JPIV_0'; 
 case 29,    LocShortExitText='CONSBS_NB_TOOBIG'; 
 case 30,    LocShortExitText='CONDNM_BAD_NBLOCKS'; 
 case 31,    LocShortExitText='CONDNM_BAD_COLLEN'; 
 case 32,    LocShortExitText='DIREC_UPDATE_ERR'; 
 case 33,    LocShortExitText='PH0FAC_INVERT_FAILURE '; 
 case 34,    LocShortExitText='PH0PIV_BAD_INDEX'; 
 case 35,    LocShortExitText='PH0PIV_XPIVOT_FAILURE'; 
 case 36,    LocShortExitText='PH0PIV_BAD_ICOLS1'; 
 case 37,    LocShortExitText='PH0PIV_BAD_ICOLS2'; 
 case 38,    LocShortExitText='OTHER_RUNTIME'; 
 
 case 39,
  LocShortExitText='USER_TERMINATION'; 
  LocExitText = 'Terminated by user function.';
  ExitFlag = 12;
 
 case 40,    LocShortExitText='JAC_OVERFLOW'; 
 
 case 41,
  LocShortExitText='OPTQUEST_ERROR'; 
  LocExitText = 'OPTQUEST Error.';
  ExitFlag = 13;
  
 case 42,
  LocShortExitText='TIME_LIMIT_EXCEEDED';
  LocExitText = 'Time limit exceeded.';
  ExitFlag = 1;

 case 43,
  LocShortExitText = 'NO_LOCALS_FOUND_INFEASIBLE';
  LocExitText = 'No locals found. Infeasible.';
  ExitFlag = 4;
  
 case 44,
  LocShortExitText = 'NO_LOCALS_FOUND_FEASIBLE';
  LocExitText = 'No locals found. Feasible.';
  ExitFlag = 4;
  
otherwise,
  LocShortExitText='';
  LocExitText=['Unknown return code ' num2str(Inform) ' (' num2str(rc) ').' ];
  ExitFlag = -1;
end

if isempty(LocExitText)
  LocExitText = deblank(LocShortExitText);
else
  LocExitText = deblank(LocExitText);
end

if isempty(AlgExitText)
  AlgExitText = 'Unknown.';
end

Result.OQNLP.AlgExitText = AlgExitText;
Result.OQNLP.LocExitText = LocExitText;

Result.ExitText = sprintf('%s %s\n%s %s', ...
                          'Sol. status:', ...
                          LocExitText, ...
                          'Alg. status:', ...
                          AlgExitText);

Result.ExitFlag = ExitFlag;
Result.Inform   = rc_loc;

% Constraint values
% if m1>0, Result.Ax  = c_k(1:m1); else Result.Ax=[]; end
% Result.c_k = c_k(m1+1:m);
% 
% Result.cJac = nlp_dc(x_k,Prob);

% Multipliers
Result.v_k = v_k;

% Variable/constraint states
optParam = Prob.optParam;

Result = StateDef(Result, x_k, Result.Ax, Result.c_k, optParam.xTol, ...
                  optParam.bTol, optParam.cTol, bl, bu, 1);

Result=endSolve(Prob,Result);

% MODIFICATION LOG
% 
% 041216 med First version made
% 050112 frhe Status codes handled totally different now.